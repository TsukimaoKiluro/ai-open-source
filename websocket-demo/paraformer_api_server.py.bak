#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Paraformer è¯­éŸ³è¯†åˆ« HTTP API æœåŠ¡
æä¾› HTTP æ¥å£ä¾› Node.js WebSocket æœåŠ¡å™¨è°ƒç”¨
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
from funasr import AutoModel
import tempfile
import os
import sys
import traceback
import logging
import subprocess
import shutil

app = Flask(__name__)
CORS(app)

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# å…¨å±€æ¨¡å‹å®ä¾‹
model = None
ffmpeg_available = False

def check_ffmpeg():
    """æ£€æŸ¥ ffmpeg æ˜¯å¦å¯ç”¨"""
    global ffmpeg_available
    try:
        result = subprocess.run(['ffmpeg', '-version'], 
                              capture_output=True, 
                              text=True, 
                              timeout=5)
        if result.returncode == 0:
            ffmpeg_available = True
            logger.info("âœ… ffmpeg å¯ç”¨")
            return True
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass
    
    # å°è¯•åœ¨ Scoop è·¯å¾„ä¸­æŸ¥æ‰¾
    scoop_ffmpeg = os.path.expanduser("~/scoop/shims/ffmpeg.exe")
    if os.path.exists(scoop_ffmpeg):
        try:
            result = subprocess.run([scoop_ffmpeg, '-version'],
                                  capture_output=True,
                                  text=True,
                                  timeout=5)
            if result.returncode == 0:
                ffmpeg_available = True
                logger.info(f"âœ… ffmpeg å¯ç”¨ (Scoop): {scoop_ffmpeg}")
                return True
        except:
            pass
    
    logger.warning("âš ï¸  ffmpeg æœªæ‰¾åˆ°ï¼ŒæŸäº›éŸ³é¢‘æ ¼å¼å¯èƒ½ä¸æ”¯æŒ")
    ffmpeg_available = False
    return False

def convert_audio_to_wav(input_path, output_path):
    """ä½¿ç”¨ ffmpeg å°†éŸ³é¢‘è½¬æ¢ä¸º WAV æ ¼å¼"""
    try:
        # æ£€æŸ¥è¾“å…¥æ–‡ä»¶
        if not os.path.exists(input_path):
            logger.error(f"âŒ è¾“å…¥æ–‡ä»¶ä¸å­˜åœ¨: {input_path}")
            return False
        
        input_size = os.path.getsize(input_path)
        if input_size < 100:
            logger.error(f"âŒ è¾“å…¥æ–‡ä»¶è¿‡å°: {input_size} å­—èŠ‚")
            return False
        
        logger.info(f"ğŸ“‚ è¾“å…¥æ–‡ä»¶: {input_path} ({input_size} å­—èŠ‚)")
        
        ffmpeg_cmd = 'ffmpeg'
        scoop_ffmpeg = os.path.expanduser("~/scoop/shims/ffmpeg.exe")
        if os.path.exists(scoop_ffmpeg):
            ffmpeg_cmd = scoop_ffmpeg
            logger.info(f"ğŸ”§ ä½¿ç”¨ Scoop ffmpeg: {scoop_ffmpeg}")
        
        cmd = [
            ffmpeg_cmd,
            '-loglevel', 'warning',  # å‡å°‘æ—¥å¿—è¾“å‡º
            '-i', input_path,
            '-ar', '16000',          # é‡‡æ ·ç‡ 16kHz
            '-ac', '1',              # å•å£°é“
            '-acodec', 'pcm_s16le',  # PCM ç¼–ç 
            '-f', 'wav',             # å¼ºåˆ¶ WAV æ ¼å¼
            '-avoid_negative_ts', 'make_zero',  # ä¿®å¤æ—¶é—´æˆ³é—®é¢˜
            '-y',                    # è¦†ç›–è¾“å‡ºæ–‡ä»¶
            output_path
        ]
        
        logger.info(f"ğŸ¬ æ‰§è¡Œ ffmpeg è½¬æ¢...")
        
        result = subprocess.run(cmd, 
                              capture_output=True, 
                              text=True, 
                              timeout=30)
        
        if result.returncode == 0:
            # éªŒè¯è¾“å‡ºæ–‡ä»¶
            if os.path.exists(output_path):
                output_size = os.path.getsize(output_path)
                logger.info(f"âœ… éŸ³é¢‘è½¬æ¢æˆåŠŸ: {output_path} ({output_size} å­—èŠ‚)")
                return True
            else:
                logger.error(f"âŒ è¾“å‡ºæ–‡ä»¶æœªç”Ÿæˆ: {output_path}")
                return False
        else:
            logger.error(f"âŒ ffmpeg è½¬æ¢å¤±è´¥ (é€€å‡ºç  {result.returncode})")
            logger.error(f"stderr: {result.stderr}")
            if result.stdout:
                logger.error(f"stdout: {result.stdout}")
            return False
    except subprocess.TimeoutExpired:
        logger.error(f"âŒ ffmpeg è½¬æ¢è¶…æ—¶ï¼ˆ>30ç§’ï¼‰")
        return False
    except Exception as e:
        logger.error(f"âŒ éŸ³é¢‘è½¬æ¢å¼‚å¸¸: {e}")
        traceback.print_exc()
        return False

def initialize_model():
    """åˆå§‹åŒ– Paraformer æ¨¡å‹"""
    global model
    logger.info("="*70)
    logger.info("æ­£åœ¨åˆå§‹åŒ– Paraformer æ–¹è¨€è¯†åˆ«æ¨¡å‹...")
    logger.info("="*70)
    
    # æ£€æŸ¥ ffmpeg
    check_ffmpeg()
    
    try:
        # åŠ è½½ Paraformer æ¨¡å‹
        model = AutoModel(
            model="paraformer-zh",
            model_revision="v2.0.4",
            device="cpu",  # ä½¿ç”¨ CPUï¼Œå¦‚éœ€ GPU æ”¹ä¸º "cuda"
            disable_update=True,  # ç¦ç”¨è‡ªåŠ¨æ›´æ–°æ£€æŸ¥
        )
        logger.info("âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼")
        logger.info(f"ğŸ“ æ¨¡å‹ç¼“å­˜: {os.path.expanduser('~/.cache/modelscope')}")
        return True
    except Exception as e:
        logger.error(f"âŒ æ¨¡å‹åŠ è½½å¤±è´¥: {e}")
        traceback.print_exc()
        return False

@app.route('/health', methods=['GET'])
def health_check():
    """å¥åº·æ£€æŸ¥æ¥å£"""
    if model is None:
        return jsonify({
            'status': 'error',
            'message': 'Model not initialized'
        }), 503
    return jsonify({
        'status': 'ok',
        'model': 'paraformer-zh',
        'version': 'v2.0.4',
        'ffmpeg': 'available' if ffmpeg_available else 'not_found'
    })

@app.route('/transcribe', methods=['POST'])
def transcribe():
    """
    è¯­éŸ³è¯†åˆ«æ¥å£
    
    æ¥å—éŸ³é¢‘æ•°æ®ï¼ˆäºŒè¿›åˆ¶æˆ– base64ï¼‰ï¼Œè¿”å›è¯†åˆ«æ–‡æœ¬
    
    è¯·æ±‚æ ¼å¼ï¼š
    - Content-Type: audio/* (äºŒè¿›åˆ¶éŸ³é¢‘)
    - Content-Type: application/json (JSON: { "audio": "base64_data", "format": "webm" })
    
    è¿”å›æ ¼å¼ï¼š
    {
        "success": true,
        "text": "è¯†åˆ«çš„æ–‡æœ¬å†…å®¹",
        "language": "zh"
    }
    """
    if model is None:
        return jsonify({
            'success': False,
            'error': 'Model not initialized'
        }), 503
    
    try:
        audio_data = None
        file_ext = ".wav"
        
        # è·å–éŸ³é¢‘æ•°æ®
        if request.content_type and 'audio' in request.content_type:
            # äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
            audio_data = request.data
            
            # ä» Content-Type æ¨æ–­æ ¼å¼
            if 'webm' in request.content_type:
                file_ext = ".webm"
            elif 'ogg' in request.content_type:
                file_ext = ".ogg"
            elif 'mp4' in request.content_type or 'm4a' in request.content_type:
                file_ext = ".m4a"
            elif 'mpeg' in request.content_type or 'mp3' in request.content_type:
                file_ext = ".mp3"
                
        elif request.is_json:
            # JSON æ ¼å¼ï¼šbase64 ç¼–ç çš„éŸ³é¢‘
            data = request.get_json()
            import base64
            audio_data = base64.b64decode(data.get('audio', ''))
            file_ext = "." + data.get('format', 'wav')
        else:
            return jsonify({
                'success': False,
                'error': 'Unsupported content type'
            }), 400
        
        if not audio_data:
            return jsonify({
                'success': False,
                'error': 'No audio data received'
            }), 400
        
        # æ£€æŸ¥éŸ³é¢‘æ•°æ®å¤§å°
        if len(audio_data) < 100:
            logger.warning(f"âš ï¸ éŸ³é¢‘æ•°æ®è¿‡å°: {len(audio_data)} å­—èŠ‚ï¼Œå¯èƒ½ä¸åŒ…å«æœ‰æ•ˆè¯­éŸ³")
            return jsonify({
                'success': True,
                'text': '',
                'language': 'zh',
                'confidence': 0.0,
                'message': 'éŸ³é¢‘æ•°æ®è¿‡å°'
            })
        
        logger.info(f"ğŸ“¥ æ”¶åˆ°éŸ³é¢‘æ•°æ®: {len(audio_data)} å­—èŠ‚, æ ¼å¼: {file_ext}")
        
        # æ‰“å°éŸ³é¢‘æ•°æ®å¤´éƒ¨ï¼ˆç”¨äºè°ƒè¯•ï¼‰
        if len(audio_data) > 16:
            header_hex = audio_data[:16].hex()
            logger.info(f"ğŸ” éŸ³é¢‘å¤´éƒ¨ (å‰16å­—èŠ‚): {header_hex}")
            
            # æ‰“å°æ›´å¤šå¤´éƒ¨ä¿¡æ¯ç”¨äºè¯Šæ–­
            if len(audio_data) > 64:
                header_64 = audio_data[:64].hex()
                logger.info(f"ğŸ” éŸ³é¢‘å¤´éƒ¨ (å‰64å­—èŠ‚): {header_64}")
        
        # éªŒè¯éŸ³é¢‘æ•°æ®ï¼ˆæ£€æŸ¥ WebM å¤´éƒ¨ï¼‰
        if file_ext == '.webm':
            # WebM æ–‡ä»¶åº”è¯¥ä»¥ 0x1A 0x45 0xDF 0xA3 å¼€å¤´ï¼ˆEBML å¤´éƒ¨ï¼‰
            if len(audio_data) > 4:
                header = audio_data[:4]
                expected_header = b'\x1a\x45\xdf\xa3'
                
                if header != expected_header:
                    logger.warning(f"âš ï¸ WebM å¤´éƒ¨ä¸åŒ¹é…")
                    logger.warning(f"   æœŸæœ›: {expected_header.hex()}")
                    logger.warning(f"   å®é™…: {header.hex()}")
                    
                    # å°è¯•åœ¨å‰ 2KB èŒƒå›´å†…æŸ¥æ‰¾ WebM EBML æ ‡è¯†
                    search_length = min(len(audio_data), 2048)
                    webm_pos = audio_data[:search_length].find(b'\x1a\x45\xdf\xa3')
                    
                    if webm_pos > 0:
                        logger.info(f"âœ… åœ¨ä½ç½® {webm_pos} æ‰¾åˆ° WebM å¤´éƒ¨ï¼Œæˆªå–æœ‰æ•ˆéƒ¨åˆ†")
                        audio_data = audio_data[webm_pos:]
                        logger.info(f"   ä¿®æ­£åæ•°æ®å¤§å°: {len(audio_data)} å­—èŠ‚")
                    elif webm_pos < 0:
                        # æ²¡æœ‰æ‰¾åˆ° WebM å¤´éƒ¨
                        logger.warning("âš ï¸ æœªæ‰¾åˆ° WebM EBML å¤´éƒ¨æ ‡è¯†")
                        logger.warning("   è¿™å¯èƒ½æ˜¯ MediaRecorder çš„ä¸­é—´æ•°æ®å—")
                        logger.warning("   å°†å°è¯•ç»§ç»­å¤„ç†ï¼Œä½†å¯èƒ½å¤±è´¥")
                        
                        # æ£€æŸ¥æ˜¯å¦æ˜¯å…¶ä»–éŸ³é¢‘æ ¼å¼
                        if audio_data[:4] == b'RIFF':
                            logger.info("   æ£€æµ‹åˆ° RIFF å¤´éƒ¨ï¼Œå¯èƒ½æ˜¯ WAV æ ¼å¼")
                            file_ext = '.wav'
                        elif audio_data[:3] == b'ID3' or audio_data[:2] == b'\xff\xfb':
                            logger.info("   æ£€æµ‹åˆ° MP3 æ ‡è¯†")
                            file_ext = '.mp3'
                else:
                    logger.info(f"âœ… WebM EBML å¤´éƒ¨éªŒè¯é€šè¿‡")
        
        # å°†éŸ³é¢‘ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
        with tempfile.NamedTemporaryFile(suffix=file_ext, delete=False) as temp_file:
            temp_path = temp_file.name
            temp_file.write(audio_data)
            temp_file.flush()  # ç¡®ä¿æ•°æ®å†™å…¥ç£ç›˜
        
        try:
            logger.info(f"ğŸ¤ æ­£åœ¨è¯†åˆ«éŸ³é¢‘: {temp_path} ({len(audio_data)} å­—èŠ‚)")
            
            # å¦‚æœä¸æ˜¯ WAV æ ¼å¼ä¸” ffmpeg å¯ç”¨ï¼Œå°è¯•è½¬æ¢
            final_audio_path = temp_path
            converted = False
            
            if file_ext.lower() != '.wav' and ffmpeg_available:
                logger.info(f"ğŸ”„ å°è¯•å°† {file_ext} è½¬æ¢ä¸º WAV æ ¼å¼...")
                wav_path = temp_path.replace(file_ext, '.wav')
                
                # å…ˆæ£€æŸ¥è¾“å…¥æ–‡ä»¶å¤§å°
                input_size = os.path.getsize(temp_path)
                logger.info(f"   è¾“å…¥æ–‡ä»¶å¤§å°: {input_size} å­—èŠ‚")
                
                if convert_audio_to_wav(temp_path, wav_path):
                    # éªŒè¯è½¬æ¢åçš„æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
                    if os.path.exists(wav_path):
                        output_size = os.path.getsize(wav_path)
                        logger.info(f"   è¾“å‡ºæ–‡ä»¶å¤§å°: {output_size} å­—èŠ‚")
                        
                        if output_size > 100:
                            final_audio_path = wav_path
                            converted = True
                            logger.info(f"âœ… ä½¿ç”¨è½¬æ¢åçš„ WAV æ–‡ä»¶")
                        else:
                            logger.error(f"âŒ è½¬æ¢åçš„ WAV æ–‡ä»¶è¿‡å° ({output_size} å­—èŠ‚)")
                            # ç»§ç»­å°è¯•ä½¿ç”¨åŸå§‹æ–‡ä»¶
                            logger.info(f"âš ï¸ å°è¯•ç›´æ¥ä½¿ç”¨åŸå§‹æ–‡ä»¶")
                    else:
                        logger.error(f"âŒ è½¬æ¢åçš„æ–‡ä»¶ä¸å­˜åœ¨: {wav_path}")
                        # ç»§ç»­å°è¯•ä½¿ç”¨åŸå§‹æ–‡ä»¶
                        logger.info(f"âš ï¸ å°è¯•ç›´æ¥ä½¿ç”¨åŸå§‹æ–‡ä»¶")
                else:
                    logger.warning(f"âš ï¸ FFmpeg è½¬æ¢å¤±è´¥ï¼Œå°è¯•ç›´æ¥è¯†åˆ«åŸå§‹æ–‡ä»¶")
                    # ä¸è¿”å›é”™è¯¯ï¼Œè€Œæ˜¯å°è¯•ç›´æ¥ä½¿ç”¨åŸå§‹æ–‡ä»¶
            elif file_ext.lower() != '.wav' and not ffmpeg_available:
                logger.warning("âš ï¸ æœªå®‰è£… ffmpegï¼Œå°è¯•ç›´æ¥è¯†åˆ«é WAV æ ¼å¼æ–‡ä»¶")
                # ä¸è¿”å›é”™è¯¯ï¼Œè®©æ¨¡å‹å°è¯•å¤„ç†
            
            # æ‰§è¡Œè¯†åˆ«
            logger.info(f"ğŸ¯ å¼€å§‹è¯†åˆ«: {final_audio_path}")
            logger.info(f"   æ–‡ä»¶å­˜åœ¨: {os.path.exists(final_audio_path)}")
            logger.info(f"   æ–‡ä»¶å¤§å°: {os.path.getsize(final_audio_path)} å­—èŠ‚")
            
            try:
                result = model.generate(input=final_audio_path)
                
                if not result or len(result) == 0:
                    logger.warning("âš ï¸ æ¨¡å‹è¿”å›ç©ºç»“æœ")
                    return jsonify({
                        'success': True,
                        'text': '',
                        'language': 'zh',
                        'confidence': 0.0,
                        'message': 'æœªæ£€æµ‹åˆ°æœ‰æ•ˆè¯­éŸ³'
                    })
                    
            except Exception as model_error:
                logger.error(f"âŒ æ¨¡å‹è¯†åˆ«å¼‚å¸¸: {model_error}")
                logger.error(f"   å¼‚å¸¸ç±»å‹: {type(model_error).__name__}")
                traceback.print_exc()
                
                error_msg = str(model_error)
                error_lower = error_msg.lower()
                
                # è¯¦ç»†çš„é”™è¯¯åˆ†ç±»
                if 'format' in error_lower or 'codec' in error_lower or 'decode' in error_lower:
                    return jsonify({
                        'success': False,
                        'error': 'éŸ³é¢‘æ ¼å¼å¤„ç†å¤±è´¥',
                        'detail': error_msg,
                        'suggestion': 'éŸ³é¢‘æ•°æ®å¯èƒ½ä¸å®Œæ•´æˆ–æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·é‡æ–°å½•éŸ³'
                    }), 500
                elif 'sample' in error_lower or 'rate' in error_lower:
                    return jsonify({
                        'success': False,
                        'error': 'éŸ³é¢‘é‡‡æ ·ç‡ä¸æ”¯æŒ',
                        'detail': error_msg,
                        'suggestion': 'è¯·ç¡®ä¿éŸ³é¢‘é‡‡æ ·ç‡ä¸º 16kHz'
                    }), 500
                elif 'channel' in error_lower:
                    return jsonify({
                        'success': False,
                        'error': 'éŸ³é¢‘é€šé“æ•°ä¸æ”¯æŒ',
                        'detail': error_msg,
                        'suggestion': 'è¯·ä½¿ç”¨å•å£°é“éŸ³é¢‘'
                    }), 500
                else:
                    # å…¶ä»–æœªçŸ¥é”™è¯¯
                    return jsonify({
                        'success': False,
                        'error': 'è¯†åˆ«å¤±è´¥',
                        'detail': error_msg,
                        'suggestion': 'è¯·æ£€æŸ¥éŸ³é¢‘è´¨é‡å¹¶é‡è¯•'
                    }), 500
            
            # æ¸…ç†è½¬æ¢çš„ä¸´æ—¶æ–‡ä»¶
            if converted and os.path.exists(final_audio_path):
                try:
                    os.unlink(final_audio_path)
                except:
                    pass
            
            if result and len(result) > 0:
                text = result[0].get("text", "")
                logger.info(f"âœ… è¯†åˆ«æˆåŠŸ: {text}")
                
                return jsonify({
                    'success': True,
                    'text': text,
                    'language': 'zh',
                    'confidence': 1.0
                })
            else:
                logger.warning("âš ï¸ æœªè¯†åˆ«åˆ°å†…å®¹")
                return jsonify({
                    'success': True,
                    'text': '',
                    'language': 'zh',
                    'confidence': 0.0
                })
        finally:
            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            try:
                os.unlink(temp_path)
            except:
                pass
                
    except Exception as e:
        logger.error(f"âŒ è¯†åˆ«å¤±è´¥: {e}")
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/transcribe-stream', methods=['POST'])
def transcribe_stream():
    """
    æµå¼è¯­éŸ³è¯†åˆ«æ¥å£ï¼ˆç´¯ç§¯å¤šä¸ªéŸ³é¢‘åˆ†ç‰‡ï¼‰
    
    è¯·æ±‚æ ¼å¼ï¼ˆJSONï¼‰ï¼š
    {
        "audio": "base64_encoded_audio_chunk",
        "format": "webm",
        "streamId": "unique-stream-id",
        "isLast": false
    }
    
    è¿”å›æ ¼å¼ï¼š
    {
        "success": true,
        "text": "ä¸­é—´ç»“æœæ–‡æœ¬",
        "isFinal": false
    }
    """
    if model is None:
        return jsonify({
            'success': False,
            'error': 'Model not initialized'
        }), 503
    
    try:
        data = request.get_json()
        stream_id = data.get('streamId', 'unknown')
        is_last = data.get('isLast', False)
        
        import base64
        audio_data = base64.b64decode(data.get('audio', ''))
        file_ext = "." + data.get('format', 'webm')
        
        if not audio_data:
            return jsonify({
                'success': False,
                'error': 'No audio data'
            }), 400
        
        # ä¿å­˜ä¸´æ—¶æ–‡ä»¶
        with tempfile.NamedTemporaryFile(suffix=file_ext, delete=False) as temp_file:
            temp_path = temp_file.name
            temp_file.write(audio_data)
        
        try:
            # æ‰§è¡Œè¯†åˆ«
            result = model.generate(input=temp_path)
            
            text = ""
            if result and len(result) > 0:
                text = result[0].get("text", "")
            
            logger.info(f"ğŸ¤ æµå¼è¯†åˆ« [{stream_id}] isFinal={is_last}: {text}")
            
            return jsonify({
                'success': True,
                'text': text,
                'isFinal': is_last,
                'streamId': stream_id
            })
        finally:
            try:
                os.unlink(temp_path)
            except:
                pass
                
    except Exception as e:
        logger.error(f"âŒ æµå¼è¯†åˆ«å¤±è´¥: {e}")
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

def main():
    """ä¸»å‡½æ•°"""
    print("\n" + "="*70)
    print("ğŸ™ï¸  Paraformer æ–¹è¨€è¯†åˆ« API æœåŠ¡")
    print("="*70)
    print(f"ğŸ Python: {sys.version.split()[0]}")
    print(f"ğŸ’¾ å·¥ä½œç›®å½•: {os.getcwd()}")
    print("="*70)
    
    # åˆå§‹åŒ–æ¨¡å‹
    if not initialize_model():
        print("\nâŒ æ¨¡å‹åˆå§‹åŒ–å¤±è´¥ï¼ŒæœåŠ¡æ— æ³•å¯åŠ¨")
        sys.exit(1)
    
    print("\n" + "="*70)
    print("âœ… API æœåŠ¡å¯åŠ¨æˆåŠŸï¼")
    print("="*70)
    print("\nğŸ“¡ API ç«¯ç‚¹:")
    print("  - GET  /health           : å¥åº·æ£€æŸ¥")
    print("  - POST /transcribe       : å•æ¬¡è¯­éŸ³è¯†åˆ«")
    print("  - POST /transcribe-stream: æµå¼è¯­éŸ³è¯†åˆ«")
    print("\nğŸŒ ç›‘å¬åœ°å€: http://127.0.0.1:5000")
    print("="*70 + "\n")
    
    # å¯åŠ¨ Flask æœåŠ¡
    app.run(host='127.0.0.1', port=5000, debug=False, threaded=True)

if __name__ == "__main__":
    main()
